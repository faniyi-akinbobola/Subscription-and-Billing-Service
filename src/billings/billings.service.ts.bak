import { Injectable } from '@nestjs/common';
import { PinoLogger, InjectPinoLogger } from 'nestjs-pino';
import {
  EmailService,
  ReceiptEmailData,
  RenewalReminderData,
} from '../email/email.service';
import Stripe from 'stripe';

export interface BillingRecord {
  id: string;
  customerId: string;
  customerEmail: string;
  customerName: string;
  invoiceId: string;
  subscriptionId?: string;
  amount: number;
  currency: string;
  status: 'paid' | 'pending' | 'failed';
  paidAt?: Date;
  createdAt: Date;
  planName?: string;
  period?: {
    start: Date;
    end: Date;
  };
}

@Injectable()
export class BillingsService {
  constructor(
    @InjectPinoLogger(BillingsService.name)
    private readonly logger: PinoLogger,
    private emailService: EmailService,
  ) {}

  /**
   * Process payment receipt and send email notification
   */
  async processPaymentReceipt(invoice: Stripe.Invoice): Promise<void> {
    try {
      if (invoice.status !== 'paid') {
        this.logger.log(
          `Invoice ${invoice.id} not paid, skipping receipt email`,
        );
        return;
      }

      // Extract customer information - handle both string ID and expanded object
      const customer =
        typeof invoice.customer === 'string'
          ? { id: invoice.customer, email: null, name: null }
          : (invoice.customer as Stripe.Customer);

      if (!customer?.email) {
        this.logger.warn(
          `No email found for customer ${customer?.id}, skipping receipt`,
        );
        return;
      }

      // Prepare receipt data
      const receiptData: ReceiptEmailData = {
        customerEmail: customer.email,
        customerName: customer.name || customer.email,
        invoiceNumber: invoice.number || invoice.id,
        amount: invoice.amount_paid,
        currency: invoice.currency,
        paidAt: new Date(invoice.status_transitions.paid_at! * 1000),
        planName: this.extractPlanName(invoice),
        period: {
          start: new Date(invoice.period_start * 1000),
          end: new Date(invoice.period_end * 1000),
        },
        pdfUrl: invoice.invoice_pdf || undefined,
      };

      // Send receipt email
      await this.emailService.sendReceiptEmail(receiptData);

      // Log billing record
      const subscriptionId = (invoice as any).subscription
        ? typeof (invoice as any).subscription === 'string'
          ? (invoice as any).subscription
          : (invoice as any).subscription.id
        : undefined;

      this.logBillingRecord({
        id: invoice.id,
        customerId: customer.id,
        customerEmail: customer.email,
        customerName: customer.name || customer.email,
        invoiceId: invoice.id,
        subscriptionId,
        amount: invoice.amount_paid,
        currency: invoice.currency,
        status: 'paid',
        paidAt: new Date(invoice.status_transitions.paid_at! * 1000),
        createdAt: new Date(invoice.created * 1000),
        planName: this.extractPlanName(invoice),
        period: {
          start: new Date(invoice.period_start * 1000),
          end: new Date(invoice.period_end * 1000),
        },
      });
    } catch (error) {
      this.logger.error(
        `Failed to process receipt for invoice ${invoice.id}:`,
        error,
      );
      throw error;
    }
  }

  /**
   * Process upcoming subscription renewals and send reminder emails
   */
  async processUpcomingRenewal(
    subscription: Stripe.Subscription,
    daysUntilRenewal: number = 3,
  ): Promise<void> {
    try {
      const customer =
        typeof subscription.customer === 'string'
          ? { id: subscription.customer, email: null, name: null }
          : (subscription.customer as Stripe.Customer);

      if (!customer?.email) {
        this.logger.warn(
          `No email found for customer ${customer?.id}, skipping renewal reminder`,
        );
        return;
      }

      // Calculate renewal date - use any to access current_period_end
      const renewalDate = new Date(
        (subscription as any).current_period_end * 1000,
      );
      const today = new Date();
      const daysDiff = Math.ceil(
        (renewalDate.getTime() - today.getTime()) / (1000 * 60 * 60 * 24),
      );

      // Only send reminder if within the specified days
      if (daysDiff !== daysUntilRenewal) {
        return;
      }

      // Get the price information
      const price = subscription.items.data[0]?.price;

      const reminderData: RenewalReminderData = {
        customerEmail: customer.email,
        customerName: customer.name || customer.email,
        planName: this.extractPlanNameFromSubscription(subscription),
        amount: price?.unit_amount || 0,
        currency: price?.currency || 'usd',
        renewalDate,
        daysUntilRenewal: daysDiff,
        subscriptionId: subscription.id,
      };

      // Send renewal reminder
      await this.emailService.sendRenewalReminderEmail(reminderData);

      this.logger.log(
        `Renewal reminder sent for subscription ${subscription.id}, renewing in ${daysDiff} days`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to process renewal reminder for subscription ${subscription.id}:`,
        error,
      );
      throw error;
    }
  }

  /**
   * Handle failed payment notifications
   */
  async processPaymentFailure(invoice: Stripe.Invoice): Promise<void> {
    try {
      const customer = invoice.customer as Stripe.Customer;

      this.logger.warn(
        `Payment failed for invoice ${invoice.id}, customer ${customer?.id}`,
      );

      // Log failed billing record
      this.logBillingRecord({
        id: invoice.id,
        customerId: customer?.id || 'unknown',
        customerEmail: customer?.email || 'unknown',
        customerName: customer?.name || customer?.email || 'unknown',
        invoiceId: invoice.id,
        subscriptionId: (invoice as any).subscription
          ? typeof (invoice as any).subscription === 'string'
            ? (invoice as any).subscription
            : (invoice as any).subscription.id
          : undefined,
        amount: invoice.amount_due,
        currency: invoice.currency,
        status: 'failed',
        createdAt: new Date(invoice.created * 1000),
        planName: this.extractPlanName(invoice),
      });

      // TODO: Implement payment failure email notification
      // await this.emailService.sendPaymentFailureEmail(...);
    } catch (error) {
      this.logger.error(
        `Failed to process payment failure for invoice ${invoice.id}:`,
        error,
      );
      throw error;
    }
  }

  /**
   * Get billing history for a customer
   */
  async getBillingHistory(customerId: string): Promise<BillingRecord[]> {
    // TODO: Implement database storage and retrieval
    // For now, this would query your database for billing records
    this.logger.log(`Retrieving billing history for customer ${customerId}`);
    return [];
  }

  /**
   * Extract plan name from invoice line items
   */
  private extractPlanName(invoice: Stripe.Invoice): string {
    const lineItem = invoice.lines.data[0];
    const price = (lineItem as any)?.price;
    return (
      price?.nickname ||
      lineItem?.description ||
      `Plan ${price?.id}` ||
      'Subscription Plan'
    );
  }

  /**
   * Extract plan name from subscription
   */
  private extractPlanNameFromSubscription(
    subscription: Stripe.Subscription,
  ): string {
    const price = subscription.items.data[0]?.price;
    const product =
      typeof price?.product === 'string'
        ? { name: price.product }
        : (price?.product as Stripe.Product);

    return (
      price?.nickname ||
      product?.name ||
      `Plan ${price?.id}` ||
      'Subscription Plan'
    );
  }

  /**
   * Log billing record (you can extend this to save to database)
   */
  private logBillingRecord(record: BillingRecord): void {
    this.logger.log(`Billing Record: ${JSON.stringify(record, null, 2)}`);

    // TODO: Save to database
    // Example:
    // await this.billingRepository.save(record);
  }

  /**
   * Schedule renewal reminders for active subscriptions
   * This could be called by a cron job to check for upcoming renewals
   */
  async scheduleRenewalReminders(stripe: Stripe): Promise<void> {
    try {
      // Get all active subscriptions
      const subscriptions = await stripe.subscriptions.list({
        status: 'active',
        limit: 100, // Process in batches
      });

      for (const subscription of subscriptions.data) {
        // Check if renewal is in 3 days (or configurable period)
        await this.processUpcomingRenewal(subscription, 3);
      }
    } catch (error) {
      this.logger.error('Failed to schedule renewal reminders:', error);
      throw error;
    }
  }
}
