import {
  Injectable,
  Inject,
  BadRequestException,
} from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { PinoLogger, InjectPinoLogger } from 'nestjs-pino';
import Stripe from 'stripe';
import {
  CreatePaymentIntentDto,
  ConfirmPaymentIntentDto,
  CreateStripeSubscriptionDto,
  CreateCustomerDto,
  CreateCheckoutSessionDto,
} from './dto';
import { BillingsService } from '../billings/billings.service';
import { SubscriptionsService } from '../subscriptions/subscriptions.service';
import { UsersService } from '../users/users.service';
import { Payment, PaymentStatus, PaymentType } from './entities/payment.entity';
import { SubscriptionStatus } from '../subscriptions/entities/subscription.entity';

@Injectable()
export class PaymentsService {
  private stripe: Stripe;

  constructor(
    @InjectPinoLogger(PaymentsService.name)
    private readonly logger: PinoLogger,
    @Inject('STRIPE_CONFIG') private stripeConfig: any,
    @InjectRepository(Payment)
    private paymentRepository: Repository<Payment>,
    private billingsService: BillingsService,
    private subscriptionsService: SubscriptionsService,
    private usersService: UsersService,
  ) {
    this.stripe = new Stripe(this.stripeConfig.secretKey, {
      apiVersion: this.stripeConfig.apiVersion,
      timeout: 60000, // 60 seconds timeout
      maxNetworkRetries: 3, // Retry failed requests 3 times
      httpAgent: undefined, // Use default HTTP agent
    });
  }

  // üí≥ Customer Management
  async createCustomer(
    createCustomerDto: CreateCustomerDto,
  ): Promise<Stripe.Customer> {
    try {
      const customer = await this.stripe.customers.create({
        email: createCustomerDto.email,
        name: createCustomerDto.name,
        phone: createCustomerDto.phone,
        metadata: createCustomerDto.metadata,
      });

      this.logger.log(`Customer created: ${customer.id}`);
      return customer;
    } catch (error) {
      this.logger.error(`Failed to create customer: ${error.message}`);
      throw new BadRequestException(
        `Failed to create customer: ${error.message}`,
      );
    }
  }

  async getCustomer(customerId: string): Promise<Stripe.Customer> {
    try {
      const customer = await this.stripe.customers.retrieve(customerId);
      return customer as Stripe.Customer;
    } catch (error) {
      this.logger.error(`Failed to retrieve customer: ${error.message}`);
      throw new BadRequestException(`Customer not found: ${customerId}`);
    }
  }

  // üéØ Payment Intent Management
  async createPaymentIntent(
    createPaymentIntentDto: CreatePaymentIntentDto,
  ): Promise<Stripe.PaymentIntent> {
    try {
      const paymentIntentData: Stripe.PaymentIntentCreateParams = {
        amount: createPaymentIntentDto.amount,
        currency: createPaymentIntentDto.currency,
        automatic_payment_methods: {
          enabled: true,
        },
        metadata: createPaymentIntentDto.metadata,
      };

      if (createPaymentIntentDto.customerId) {
        paymentIntentData.customer = createPaymentIntentDto.customerId;
      }

      if (createPaymentIntentDto.paymentMethodId) {
        paymentIntentData.payment_method =
          createPaymentIntentDto.paymentMethodId;
        paymentIntentData.confirm = true;
      }

      if (createPaymentIntentDto.description) {
        paymentIntentData.description = createPaymentIntentDto.description;
      }

      const paymentIntent =
        await this.stripe.paymentIntents.create(paymentIntentData);

      this.logger.log(`Payment intent created: ${paymentIntent.id}`);
      return paymentIntent;
    } catch (error) {
      this.logger.error(`Failed to create payment intent: ${error.message}`);
      throw new BadRequestException(
        `Failed to create payment intent: ${error.message}`,
      );
    }
  }

  async confirmPaymentIntent(
    confirmPaymentIntentDto: ConfirmPaymentIntentDto,
  ): Promise<Stripe.PaymentIntent> {
    try {
      const paymentIntent = await this.stripe.paymentIntents.confirm(
        confirmPaymentIntentDto.paymentIntentId,
        {
          payment_method: confirmPaymentIntentDto.paymentMethodId,
          return_url: 'http://localhost:3000/payments/return',
        },
      );

      this.logger.log(`Payment intent confirmed: ${paymentIntent.id}`);
      return paymentIntent;
    } catch (error) {
      this.logger.error(`Failed to confirm payment intent: ${error.message}`);
      throw new BadRequestException(
        `Failed to confirm payment intent: ${error.message}`,
      );
    }
  }

  // üõí Checkout Session Management
  async createCheckoutSession(
    createCheckoutSessionDto: CreateCheckoutSessionDto,
  ): Promise<Stripe.Checkout.Session> {
    try {
      const sessionData: Stripe.Checkout.SessionCreateParams = {
        payment_method_types: ['card'],
        line_items: [
          {
            price_data: {
              currency: createCheckoutSessionDto.currency,
              product_data: {
                name: createCheckoutSessionDto.description || 'Payment',
              },
              unit_amount: createCheckoutSessionDto.amount,
            },
            quantity: 1,
          },
        ],
        mode: 'payment',
        success_url: createCheckoutSessionDto.success_url,
        cancel_url: createCheckoutSessionDto.cancel_url,
        metadata: createCheckoutSessionDto.metadata || {},
      };

      if (createCheckoutSessionDto.customerId) {
        sessionData.customer = createCheckoutSessionDto.customerId;
      }

      const session = await this.stripe.checkout.sessions.create(sessionData);

      this.logger.log(`Checkout session created: ${session.id}`);
      return session;
    } catch (error) {
      this.logger.error(`Failed to create checkout session: ${error.message}`);
      throw new BadRequestException(
        `Failed to create checkout session: ${error.message}`,
      );
    }
  }

  async getPaymentIntent(
    paymentIntentId: string,
  ): Promise<Stripe.PaymentIntent> {
    try {
      const paymentIntent =
        await this.stripe.paymentIntents.retrieve(paymentIntentId);
      return paymentIntent;
    } catch (error) {
      this.logger.error(`Failed to retrieve payment intent: ${error.message}`);
      throw new BadRequestException(
        `Payment intent not found: ${paymentIntentId}`,
      );
    }
  }

  // üìÖ Subscription Management
  async createSubscription(
    createSubscriptionDto: CreateStripeSubscriptionDto,
  ): Promise<Stripe.Subscription> {
    try {
      const subscriptionData: Stripe.SubscriptionCreateParams = {
        customer: createSubscriptionDto.customerId,
        items: [
          {
            price: createSubscriptionDto.priceId,
          },
        ],
        payment_behavior: 'default_incomplete',
        payment_settings: { save_default_payment_method: 'on_subscription' },
        expand: ['latest_invoice.payment_intent'],
        metadata: createSubscriptionDto.metadata,
      };

      if (createSubscriptionDto.paymentMethodId) {
        subscriptionData.default_payment_method =
          createSubscriptionDto.paymentMethodId;
      }

      const subscription =
        await this.stripe.subscriptions.create(subscriptionData);

      this.logger.log(`Subscription created: ${subscription.id}`);
      return subscription;
    } catch (error) {
      this.logger.error(`Failed to create subscription: ${error.message}`);
      throw new BadRequestException(
        `Failed to create subscription: ${error.message}`,
      );
    }
  }

  async getSubscription(subscriptionId: string): Promise<Stripe.Subscription> {
    try {
      const subscription =
        await this.stripe.subscriptions.retrieve(subscriptionId);
      return subscription;
    } catch (error) {
      this.logger.error(`Failed to retrieve subscription: ${error.message}`);
      throw new BadRequestException(
        `Subscription not found: ${subscriptionId}`,
      );
    }
  }

  async updateSubscription(
    subscriptionId: string,
    priceId: string,
  ): Promise<Stripe.Subscription> {
    try {
      const subscription =
        await this.stripe.subscriptions.retrieve(subscriptionId);

      const updatedSubscription = await this.stripe.subscriptions.update(
        subscriptionId,
        {
          items: [
            {
              id: subscription.items.data[0].id,
              price: priceId,
            },
          ],
        },
      );

      this.logger.log(`Subscription updated: ${subscriptionId}`);
      return updatedSubscription;
    } catch (error) {
      this.logger.error(`Failed to update subscription: ${error.message}`);
      throw new BadRequestException(
        `Failed to update subscription: ${error.message}`,
      );
    }
  }

  async cancelSubscription(
    subscriptionId: string,
  ): Promise<Stripe.Subscription> {
    try {
      const subscription =
        await this.stripe.subscriptions.cancel(subscriptionId);
      this.logger.log(`Subscription cancelled: ${subscriptionId}`);
      return subscription;
    } catch (error) {
      this.logger.error(`Failed to cancel subscription: ${error.message}`);
      throw new BadRequestException(
        `Failed to cancel subscription: ${error.message}`,
      );
    }
  }

  // üí∞ Price and Product Management
  async createPrice(
    amount: number,
    currency: string,
    interval: 'month' | 'year',
    productId?: string,
  ): Promise<Stripe.Price> {
    try {
      const priceData: Stripe.PriceCreateParams = {
        unit_amount: amount,
        currency,
        recurring: { interval },
        metadata: {},
      };

      if (productId) {
        priceData.product = productId;
      } else {
        priceData.product_data = {
          name: `Subscription Plan - ${interval}ly`,
        };
      }

      const price = await this.stripe.prices.create(priceData);

      this.logger.log(`Price created: ${price.id}`);
      return price;
    } catch (error) {
      this.logger.error(`Failed to create price: ${error.message}`);
      throw new BadRequestException(`Failed to create price: ${error.message}`);
    }
  }

  async listPrices(): Promise<Stripe.ApiList<Stripe.Price>> {
    try {
      const prices = await this.stripe.prices.list({
        active: true,
        expand: ['data.product'],
      });
      return prices;
    } catch (error) {
      this.logger.error(`Failed to list prices: ${error.message}`);
      throw new BadRequestException(`Failed to list prices: ${error.message}`);
    }
  }

  // üé´ Payment Methods
  async attachPaymentMethod(
    paymentMethodId: string,
    customerId: string,
  ): Promise<Stripe.PaymentMethod> {
    try {
      const paymentMethod = await this.stripe.paymentMethods.attach(
        paymentMethodId,
        {
          customer: customerId,
        },
      );

      this.logger.log(
        `Payment method attached: ${paymentMethodId} to customer: ${customerId}`,
      );
      return paymentMethod;
    } catch (error) {
      this.logger.error(`Failed to attach payment method: ${error.message}`);
      throw new BadRequestException(
        `Failed to attach payment method: ${error.message}`,
      );
    }
  }

  async listPaymentMethods(
    customerId: string,
  ): Promise<Stripe.ApiList<Stripe.PaymentMethod>> {
    try {
      const paymentMethods = await this.stripe.paymentMethods.list({
        customer: customerId,
        type: 'card',
      });
      return paymentMethods;
    } catch (error) {
      this.logger.error(`Failed to list payment methods: ${error.message}`);
      throw new BadRequestException(
        `Failed to list payment methods: ${error.message}`,
      );
    }
  }

  // üìã Invoices
  async getInvoice(invoiceId: string): Promise<Stripe.Invoice> {
    try {
      const invoice = await this.stripe.invoices.retrieve(invoiceId);
      return invoice;
    } catch (error) {
      this.logger.error(`Failed to retrieve invoice: ${error.message}`);
      throw new BadRequestException(`Invoice not found: ${invoiceId}`);
    }
  }

  async listInvoices(
    customerId?: string,
  ): Promise<Stripe.ApiList<Stripe.Invoice>> {
    try {
      const params: Stripe.InvoiceListParams = {
        limit: 100,
      };

      if (customerId) {
        params.customer = customerId;
      }

      const invoices = await this.stripe.invoices.list(params);
      return invoices;
    } catch (error) {
      this.logger.error(`Failed to list invoices: ${error.message}`);
      throw new BadRequestException(
        `Failed to list invoices: ${error.message}`,
      );
    }
  }

  // üîê Webhook Event Processing
  async processWebhookEvent(payload: string, signature: string): Promise<any> {
    try {
      const event = this.stripe.webhooks.constructEvent(
        payload,
        signature,
        this.stripeConfig.webhookSecret,
        undefined, // Default timestamp tolerance (5 minutes)
        // For testing/development, you can increase tolerance:
        // 600 // 10 minutes in seconds
      );

      this.logger.log(`Processing webhook event: ${event.type}`);

      switch (event.type) {
        case 'payment_intent.succeeded':
          await this.handlePaymentIntentSucceeded(
            event.data.object as Stripe.PaymentIntent,
          );
          break;

        case 'payment_intent.payment_failed':
          await this.handlePaymentIntentFailed(
            event.data.object as Stripe.PaymentIntent,
          );
          break;

        case 'invoice.payment_succeeded':
          await this.handleInvoicePaymentSucceeded(
            event.data.object as Stripe.Invoice,
          );
          break;

        case 'invoice.payment_failed':
          await this.handleInvoicePaymentFailed(
            event.data.object as Stripe.Invoice,
          );
          break;

        case 'customer.subscription.created':
          await this.handleSubscriptionCreated(
            event.data.object as Stripe.Subscription,
          );
          break;

        case 'customer.subscription.updated':
          await this.handleSubscriptionUpdated(
            event.data.object as Stripe.Subscription,
          );
          break;

        case 'customer.subscription.deleted':
          await this.handleSubscriptionDeleted(
            event.data.object as Stripe.Subscription,
          );
          break;

        case 'customer.subscription.trial_will_end':
          await this.handleSubscriptionTrialWillEnd(
            event.data.object as Stripe.Subscription,
          );
          break;

        default:
          this.logger.warn(`Unhandled webhook event type: ${event.type}`);
      }

      return { received: true };
    } catch (error) {
      this.logger.error(`Webhook processing failed: ${error.message}`);
      throw new BadRequestException(
        `Webhook processing failed: ${error.message}`,
      );
    }
  }

  // üéØ Private Webhook Handlers
  private async handlePaymentIntentSucceeded(
    paymentIntent: Stripe.PaymentIntent,
  ): Promise<void> {
    this.logger.log(`Payment successful for: ${paymentIntent.id}`);

    try {
      // Extract customer and user information
      const customerId =
        typeof paymentIntent.customer === 'string'
          ? paymentIntent.customer
          : paymentIntent.customer?.id;

      if (!customerId) {
        this.logger.warn(
          `Payment ${paymentIntent.id} has no customer, skipping database record`,
        );
        return;
      }

      // Find user by stripe customer ID from metadata or email
      let userId: string | undefined = paymentIntent.metadata?.userId;

      if (!userId && paymentIntent.receipt_email) {
        try {
          const user = await this.usersService.findUserByMail(
            paymentIntent.receipt_email,
          );
          if (user) {
            userId = user.id;
          }
        } catch (error) {
          this.logger.warn(
            `User not found for email ${paymentIntent.receipt_email}`,
          );
        }
      }

      if (!userId) {
        this.logger.warn(
          `Could not find user for payment ${paymentIntent.id}, skipping database record`,
        );
        return;
      }

      // Create or update payment record
      const existingPayment = await this.paymentRepository.findOne({
        where: { stripePaymentIntentId: paymentIntent.id },
      });

      if (existingPayment) {
        // Update existing payment
        existingPayment.status = PaymentStatus.SUCCEEDED;
        existingPayment.amount = paymentIntent.amount / 100; // Convert from cents
        existingPayment.processedAt = new Date();
        await this.paymentRepository.save(existingPayment);
        this.logger.log(`Updated payment record: ${existingPayment.id}`);
      } else {
        // Create new payment record
        const payment = this.paymentRepository.create({
          stripePaymentIntentId: paymentIntent.id,
          stripeCustomerId: customerId,
          userId: userId,
          amount: paymentIntent.amount / 100, // Convert from cents
          currency: paymentIntent.currency,
          status: PaymentStatus.SUCCEEDED,
          type: paymentIntent.metadata?.subscriptionId
            ? PaymentType.SUBSCRIPTION
            : PaymentType.ONE_TIME,
          description: paymentIntent.description || 'Payment',
          metadata: paymentIntent.metadata,
          processedAt: new Date(),
        });

        await this.paymentRepository.save(payment);
        this.logger.log(`Created payment record: ${payment.id}`);
      }
    } catch (error) {
      this.logger.error(
        `Failed to save payment record for ${paymentIntent.id}: ${error.message}`,
      );
      // Don't throw - webhook should still return 200
    }
  }

  private async handlePaymentIntentFailed(
    paymentIntent: Stripe.PaymentIntent,
  ): Promise<void> {
    this.logger.log(`Payment failed for: ${paymentIntent.id}`);

    try {
      const customerId =
        typeof paymentIntent.customer === 'string'
          ? paymentIntent.customer
          : paymentIntent.customer?.id;

      if (!customerId) {
        this.logger.warn(
          `Failed payment ${paymentIntent.id} has no customer, skipping database record`,
        );
        return;
      }

      // Find user
      let userId: string | undefined = paymentIntent.metadata?.userId;

      if (!userId && paymentIntent.receipt_email) {
        try {
          const user = await this.usersService.findUserByMail(
            paymentIntent.receipt_email,
          );
          if (user) {
            userId = user.id;
          }
        } catch (error) {
          this.logger.warn(
            `User not found for email ${paymentIntent.receipt_email}`,
          );
        }
      }

      if (!userId) {
        this.logger.warn(
          `Could not find user for failed payment ${paymentIntent.id}`,
        );
        return;
      }

      // Create or update payment record
      const existingPayment = await this.paymentRepository.findOne({
        where: { stripePaymentIntentId: paymentIntent.id },
      });

      if (existingPayment) {
        existingPayment.status = PaymentStatus.FAILED;
        existingPayment.metadata = {
          ...existingPayment.metadata,
          failureReason: paymentIntent.last_payment_error?.message,
        };
        await this.paymentRepository.save(existingPayment);
        this.logger.log(`Updated failed payment record: ${existingPayment.id}`);
      } else {
        const payment = this.paymentRepository.create({
          stripePaymentIntentId: paymentIntent.id,
          stripeCustomerId: customerId,
          userId: userId,
          amount: paymentIntent.amount / 100,
          currency: paymentIntent.currency,
          status: PaymentStatus.FAILED,
          type: paymentIntent.metadata?.subscriptionId
            ? PaymentType.SUBSCRIPTION
            : PaymentType.ONE_TIME,
          description: paymentIntent.description || 'Payment',
          metadata: {
            ...paymentIntent.metadata,
            failureReason: paymentIntent.last_payment_error?.message,
          },
        });

        await this.paymentRepository.save(payment);
        this.logger.log(`Created failed payment record: ${payment.id}`);
      }

      // TODO: Send failure notification email to customer
    } catch (error) {
      this.logger.error(
        `Failed to process failed payment ${paymentIntent.id}: ${error.message}`,
      );
    }
  }

  private async handleInvoicePaymentSucceeded(
    invoice: Stripe.Invoice,
  ): Promise<void> {
    this.logger.log(`Invoice payment successful: ${invoice.id}`);

    // Process receipt email and billing record
    await this.billingsService.processPaymentReceipt(invoice);
  }

  private async handleInvoicePaymentFailed(
    invoice: Stripe.Invoice,
  ): Promise<void> {
    this.logger.log(`Invoice payment failed: ${invoice.id}`);

    // Process payment failure
    await this.billingsService.processPaymentFailure(invoice);
  }

  private async handleSubscriptionUpdated(
    subscription: Stripe.Subscription,
  ): Promise<void> {
    this.logger.log(`Subscription updated: ${subscription.id}`);

    try {
      // Extract customer and subscription information
      const customerId =
        typeof subscription.customer === 'string'
          ? subscription.customer
          : subscription.customer?.id;

      if (!customerId) {
        this.logger.warn(
          `Subscription ${subscription.id} has no customer, skipping sync`,
        );
        return;
      }

      // Find user by customer ID from metadata
      const userId = subscription.metadata?.userId;

      if (!userId) {
        this.logger.warn(
          `Subscription ${subscription.id} has no userId in metadata, skipping sync`,
        );
        return;
      }

      // Find existing subscription in database by stripe subscription ID
      const subscriptions = await this.subscriptionsService.findByUser(userId);
      const existingSubscription = subscriptions.find(
        (sub) => sub.paymentReference === subscription.id,
      );

      if (!existingSubscription) {
        this.logger.warn(
          `Local subscription not found for Stripe subscription ${subscription.id}`,
        );
        return;
      }

      // Map Stripe subscription status to local status
      let localStatus: SubscriptionStatus;
      switch (subscription.status) {
        case 'active':
          localStatus = SubscriptionStatus.ACTIVE;
          break;
        case 'trialing':
          localStatus = SubscriptionStatus.TRIAL;
          break;
        case 'past_due':
          localStatus = SubscriptionStatus.PAST_DUE;
          break;
        case 'canceled':
          localStatus = SubscriptionStatus.CANCELLED;
          break;
        case 'unpaid':
          localStatus = SubscriptionStatus.SUSPENDED;
          break;
        default:
          localStatus = SubscriptionStatus.ACTIVE;
      }

      // Update local subscription
      const updateData: any = {
        status: localStatus,
      };

      // Update dates if changed
      const currentPeriodEnd = (subscription as any).current_period_end;
      if (currentPeriodEnd) {
        updateData.endDate = new Date(currentPeriodEnd * 1000);
      }

      const currentPeriodStart = (subscription as any).current_period_start;
      if (currentPeriodStart) {
        updateData.startDate = new Date(currentPeriodStart * 1000);
      }

      // Update trial end date if in trial
      if (subscription.trial_end) {
        updateData.trialEndDate = new Date(subscription.trial_end * 1000);
      }

      // Update auto-renew status
      if (subscription.cancel_at_period_end !== undefined) {
        updateData.isAutoRenew = !subscription.cancel_at_period_end;
      }

      await this.subscriptionsService.update(
        existingSubscription.id,
        updateData,
      );

      this.logger.log(
        `Successfully synced subscription ${existingSubscription.id} with Stripe`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to sync subscription ${subscription.id}: ${error.message}`,
      );
      // Don't throw - webhook should still return 200
    }
  }

  private async handleSubscriptionDeleted(
    subscription: Stripe.Subscription,
  ): Promise<void> {
    this.logger.log(`Subscription deleted: ${subscription.id}`);

    try {
      // Extract user information
      const userId = subscription.metadata?.userId;

      if (!userId) {
        this.logger.warn(
          `Subscription ${subscription.id} has no userId in metadata, skipping deletion sync`,
        );
        return;
      }

      // Find existing subscription in database
      const subscriptions = await this.subscriptionsService.findByUser(userId);
      const existingSubscription = subscriptions.find(
        (sub) => sub.paymentReference === subscription.id,
      );

      if (!existingSubscription) {
        this.logger.warn(
          `Local subscription not found for Stripe subscription ${subscription.id}`,
        );
        return;
      }

      // Update subscription to cancelled status
      await this.subscriptionsService.update(existingSubscription.id, {
        status: SubscriptionStatus.CANCELLED,
        isAutoRenew: false,
      });

      this.logger.log(
        `Successfully marked subscription ${existingSubscription.id} as cancelled`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to handle subscription deletion ${subscription.id}: ${error.message}`,
      );
      // Don't throw - webhook should still return 200
    }
  }

  private async handleSubscriptionCreated(
    subscription: Stripe.Subscription,
  ): Promise<void> {
    this.logger.log(`Subscription created: ${subscription.id}`);

    try {
      const userId = subscription.metadata?.userId;

      if (!userId) {
        this.logger.warn(
          `Subscription ${subscription.id} has no userId in metadata, skipping creation sync`,
        );
        return;
      }

      // Check if subscription already exists in database
      const subscriptions = await this.subscriptionsService.findByUser(userId);
      const existingSubscription = subscriptions.find(
        (sub) => sub.paymentReference === subscription.id,
      );

      if (existingSubscription) {
        this.logger.log(
          `Subscription ${subscription.id} already exists in database, syncing status`,
        );
        await this.handleSubscriptionUpdated(subscription);
        return;
      }

      this.logger.log(
        `New subscription ${subscription.id} created via Stripe webhook - consider creating in database if needed`,
      );
    } catch (error) {
      this.logger.error(
        `Failed to handle subscription creation ${subscription.id}: ${error.message}`,
      );
    }
  }

  private async handleSubscriptionTrialWillEnd(
    subscription: Stripe.Subscription,
  ): Promise<void> {
    this.logger.log(`Subscription trial ending soon: ${subscription.id}`);

    try {
      const userId = subscription.metadata?.userId;

      if (!userId) {
        this.logger.warn(
          `Subscription ${subscription.id} has no userId in metadata`,
        );
        return;
      }

      // Find existing subscription
      const subscriptions = await this.subscriptionsService.findByUser(userId);
      const existingSubscription = subscriptions.find(
        (sub) => sub.paymentReference === subscription.id,
      );

      if (!existingSubscription) {
        this.logger.warn(
          `Local subscription not found for Stripe subscription ${subscription.id}`,
        );
        return;
      }

      // Send trial ending reminder (3 days before)
      const daysUntilEnd = subscription.trial_end
        ? Math.ceil(
            (subscription.trial_end * 1000 - Date.now()) / (1000 * 60 * 60 * 24),
          )
        : 0;

      this.logger.log(
        `Trial for subscription ${subscription.id} ends in ${daysUntilEnd} days`,
      );

      // You can add email notification here
      // await this.billingsService.sendTrialEndingEmail(subscription);
    } catch (error) {
      this.logger.error(
        `Failed to handle trial ending for ${subscription.id}: ${error.message}`,
      );
    }
  }
}
